/**
 * DataTable Component
 * 
 * Display data in a customizable table format.
 * Supports sorting, filtering, and pagination.
 */

---
import type { DataSource } from '../types';
import { fetchFromDirectus } from '../utils/directus';
import { fetchRemoteData } from '../utils/content';

interface Props {
  source: DataSource;
  columns?: string[];
  sortable?: boolean;
  filterable?: boolean;
  pageSize?: number;
}

const {
  source,
  columns,
  sortable = true,
  filterable = true,
  pageSize = 25
} = Astro.props;

// Fetch data
let data: any[] = [];

if ('directus' in source) {
  data = await fetchFromDirectus(source.directus);
} else if ('path2data' in source) {
  data = await fetchRemoteData(source.path2data.path);
}

// Auto-detect columns if not provided
const tableColumns = columns || (data.length > 0 ? Object.keys(data[0]) : []);

const tableId = `table-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="datatable-component" data-table-id={tableId}>
  {filterable && (
    <div class="table-filter">
      <input
        type="text"
        class="filter-input"
        placeholder="Filter table..."
      />
    </div>
  )}

  <div class="table-wrapper">
    <table class="data-table">
      <thead>
        <tr>
          {tableColumns.map(col => (
            <th data-column={col} class={sortable ? 'sortable' : ''}>
              {col}
              {sortable && <span class="sort-icon"></span>}
            </th>
          ))}
        </tr>
      </thead>
      <tbody data-items={JSON.stringify(data)}>
        {data.slice(0, pageSize).map(row => (
          <tr>
            {tableColumns.map(col => (
              <td>{row[col]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  </div>

  {data.length > pageSize && (
    <div class="table-pagination">
      <button data-action="prev" disabled>Previous</button>
      <span class="page-info">Page 1 of {Math.ceil(data.length / pageSize)}</span>
      <button data-action="next">Next</button>
    </div>
  )}
</div>

<script define:vars={{ tableColumns, sortable, filterable, pageSize }}>
  document.addEventListener('DOMContentLoaded', () => {
    const tables = document.querySelectorAll('.datatable-component');
    
    tables.forEach(tableComp => {
      const tbody = tableComp.querySelector('tbody');
      const filterInput = tableComp.querySelector('.filter-input');
      const headers = tableComp.querySelectorAll('th.sortable');
      const pagination = tableComp.querySelector('.table-pagination');
      
      if (!tbody) return;
      
      const allItems = JSON.parse(tbody.dataset.items || '[]');
      let filteredItems = [...allItems];
      let currentPage = 1;
      let sortColumn = null;
      let sortAsc = true;
      
      function renderTable() {
        const start = (currentPage - 1) * pageSize;
        const end = start + pageSize;
        const pageItems = filteredItems.slice(start, end);
        
        tbody.innerHTML = pageItems.map(row => {
          return `<tr>${tableColumns.map(col => 
            `<td>${row[col] ?? ''}</td>`
          ).join('')}</tr>`;
        }).join('');
        
        if (pagination) {
          const totalPages = Math.ceil(filteredItems.length / pageSize);
          const prevBtn = pagination.querySelector('[data-action="prev"]');
          const nextBtn = pagination.querySelector('[data-action="next"]');
          const pageInfo = pagination.querySelector('.page-info');
          
          prevBtn.disabled = currentPage === 1;
          nextBtn.disabled = currentPage === totalPages;
          pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        }
      }
      
      if (sortable) {
        headers.forEach(header => {
          header.addEventListener('click', () => {
            const column = header.dataset.column;
            if (sortColumn === column) {
              sortAsc = !sortAsc;
            } else {
              sortColumn = column;
              sortAsc = true;
            }
            
            filteredItems.sort((a, b) => {
              const aVal = a[column];
              const bVal = b[column];
              if (aVal === bVal) return 0;
              const result = aVal > bVal ? 1 : -1;
              return sortAsc ? result : -result;
            });
            
            currentPage = 1;
            renderTable();
          });
        });
      }
      
      if (filterInput) {
        filterInput.addEventListener('input', (e) => {
          const query = e.target.value.toLowerCase();
          if (!query) {
            filteredItems = [...allItems];
          } else {
            filteredItems = allItems.filter(item =>
              tableColumns.some(col =>
                String(item[col] || '').toLowerCase().includes(query)
              )
            );
          }
          currentPage = 1;
          renderTable();
        });
      }
      
      if (pagination) {
        pagination.addEventListener('click', (e) => {
          const action = e.target.dataset.action;
          if (action === 'prev' && currentPage > 1) {
            currentPage--;
            renderTable();
          } else if (action === 'next') {
            const totalPages = Math.ceil(filteredItems.length / pageSize);
            if (currentPage < totalPages) {
              currentPage++;
              renderTable();
            }
          }
        });
      }
    });
  });
</script>

<style>
  .datatable-component {
    margin: 2rem 0;
  }

  .table-filter {
    margin-bottom: 1rem;
  }

  .filter-input {
    width: 100%;
    max-width: 400px;
    padding: 0.75rem;
    border: 1px solid #e5e5e5;
    border-radius: 6px;
  }

  .table-wrapper {
    overflow-x: auto;
  }

  .data-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
  }

  .data-table th {
    background: #f5f5f5;
    padding: 1rem;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid #e5e5e5;
  }

  .data-table th.sortable {
    cursor: pointer;
    user-select: none;
  }

  .data-table th.sortable:hover {
    background: #ebebeb;
  }

  .data-table td {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #e5e5e5;
  }

  .data-table tr:hover {
    background: #f9f9f9;
  }

  .table-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-top: 1.5rem;
  }

  .table-pagination button {
    padding: 0.5rem 1rem;
    background: #fe04fc;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }

  .table-pagination button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
</style>
